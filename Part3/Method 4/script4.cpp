// extracts num_threads, runtime and utility from files with names of the form method4_output_?.txt where ? is the number of threads
// takes as command line arguments: x y - where range x to y is the range of number of threads
// performs the required task for the files present in directory, absent files are ignored with a warning on the console

#include<iostream>
#include<string>
#include<vector>
#include<fstream>
#include<sstream>
#include<cmath>

using namespace std;

// function that reads the ouput file generated by method 2,returns a vector of density values and extracts the value of runtime from the file
vector<double> read(string filename, double &runtime){
  ifstream infile;
  infile.open(filename);
  string line,heading;
  vector<double> density_values;
  if(infile.is_open()){
    infile >> heading;   /// ignore heading
    string word1;
    double density;
    while(getline(infile >> std::ws,line)){
      stringstream my_stream(line);
      my_stream >> word1;
      if(word1=="Method4"){
        my_stream >> word1; my_stream >> word1; my_stream >> word1; // removing additional words
        my_stream >> runtime;
        break;
      }
      else if(word1=="Baseline"){
        my_stream >> word1; my_stream >> word1; my_stream >> word1; // removing additional words
        my_stream >> runtime;
        break;
      }
      else{
        my_stream >> density;
        density_values.push_back(density);
      }
    }
  }
  else{
    cout<<"Unable to open output file "<<filename<<'\n';
    cout<<"Can't find utility\n";
  }
  return density_values;
}

int main(int argc, char** argv) {
  if(argc!=3 ){
    cout<<"Please provide two number_of_threads values as command line arguments";
    return -1;
  }
  
  int thread_begin = atoi(argv[1]);
  int thread_end = atoi(argv[2]);

  ofstream runtime_utility_file;
  string filename = "method4_runtime_utility";
  runtime_utility_file.open(filename);
  runtime_utility_file<<"Parameter\tRuntime\tUtility\tBaseline Runtime\n";

  double baseline_runtime;
  vector<double> baseline_densities = read("baseline_output.txt", baseline_runtime);
  if(baseline_densities.size() == 0){
      cout<<"Unable to calculate utility in absence of baseline values\n";
      return -1;
  }  
  vector<double> densities;
  string outputfile_name;
  for(int i=thread_begin; i<=thread_end; i++)
  {
    outputfile_name = "method4_output_"+to_string(i);
    double runtime;
    densities = read(outputfile_name, runtime);
    double avg_err, avg_percent_err, utility;
    if(densities.size() > 0){
      double err_sum = 0;
      double percent_err_sum = 0;
      for(size_t k = 0; k<baseline_densities.size(); k++){    //// i<baseline_densities.size() because that is precisely the no. of Frames
        double curr_diff = abs(baseline_densities[k]-densities[k]);
        err_sum += pow(baseline_densities[i]-densities[i],2);
        if(baseline_densities[k] != 0){
          percent_err_sum += (100*curr_diff/ baseline_densities[k]);
        }
      }
      avg_err = err_sum/baseline_densities.size();
      avg_percent_err = percent_err_sum/baseline_densities.size();
      utility = 100 - avg_percent_err;
      cout<<"Average error for "<<outputfile_name<<" = "<<avg_err<<endl;
      cout<<"Average percentage error for "<<outputfile_name<<" = "<<avg_percent_err<<endl;
      cout<<"Utility for "<<outputfile_name<<" = "<<utility<<endl;
      runtime_utility_file<<i<<'\t'<<runtime<<'\t'<<utility<<'\t'<<baseline_runtime<<'\n';
    }
    else{
      cout<<"Error in file "<<outputfile_name<<'\n';
    }
  }
  return 0;
}
