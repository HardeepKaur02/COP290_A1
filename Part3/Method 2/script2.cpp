// extracts resolution factor, runtime and utility from files with names of the form method2_output_?.txt where ? is the resolution factor
// takes as command line arguments: a,d,n the start value, difference and number of terms in the A.P. formed by resolution factors
// performs the required task for the files present in directory, absent files are ignored with a warning on the console

#include<iostream>
#include<string>
#include<vector>
#include<fstream>
#include<sstream>
#include<cmath>

using namespace std;

// function that reads the ouput file generated by method 2,returns a vector of density values and extracts the value of runtime from the file
vector<double> read(string filename, double &runtime){
  ifstream infile;
  infile.open(filename);
  string line,heading;
  vector<double> density_values;
  if(infile.is_open()){
    infile >> heading;   /// ignore heading
    string word1;
    double density;
    while(getline(infile >> std::ws,line)){
      stringstream my_stream(line);
      my_stream >> word1;
      if(word1=="Method2"){
        my_stream >> word1; my_stream >> word1; my_stream >> word1; // removing additional words
        my_stream >> runtime;
        break;
      }
      else if(word1=="Baseline"){
        my_stream >> word1; my_stream >> word1; my_stream >> word1; // removing additional words
        my_stream >> runtime;
        break;
      }
      else{
        my_stream >> density;
        density_values.push_back(density);
      }
    }
  }
  else{
    cout<<"Unable to open output file "<<filename<<'\n';
    cout<<"Can't find utility\n";
  }
  return density_values;
}

int main(int argc, char** argv) {
  if(argc != 4){
    cout<<"Please provide a,d,n as command line arguments";
    return -1;
  }
  double start_x = stod((string)argv[1]);
  double difference = stod((string)argv[2]);
  int n = atoi(argv[3]);

  ofstream runtime_utility_file;
  string filename = "method2_runtime_utility";
  runtime_utility_file.open(filename);
  runtime_utility_file<<"Parameter\tRuntime\tUtility\tBaseline Runtime\n";

  double baseline_runtime;
  vector<double> baseline_densities = read("baseline_output.txt", baseline_runtime);
  if(baseline_densities.size() == 0){
      cout<<"Unable to calculate utility in absence of baseline values\n";
      return -1;
  }
  vector<double> densities;
  string outputfile_name;
  double i = start_x;

  for(int j=0;j<n;j++)
  {
    ostringstream my_stream;
    my_stream<<i;
    string res_factor = my_stream.str();
    outputfile_name = "method2_output_"+res_factor;
    double runtime;
    densities = read(outputfile_name, runtime);
    double avg_err, avg_percent_err, utility;
    if(densities.size() > 0){
      double err_sum = 0;
      double percent_err_sum = 0;
      for(size_t k = 0; k<baseline_densities.size(); k++){    //// i<baseline_densities.size() because that is precisely the no. of Frames
        double curr_diff = abs(baseline_densities[k]-densities[k]);
        err_sum += pow(curr_diff,2);
        if(baseline_densities[k] != 0){
          percent_err_sum += (100*curr_diff/ baseline_densities[k]);
        }
      }
      avg_err = err_sum/baseline_densities.size();
      avg_percent_err = percent_err_sum/baseline_densities.size();
      utility = 100 - avg_percent_err;
      cout<<"Average error for "<<outputfile_name<<" = "<<avg_err<<endl;
      cout<<"Average percentage error for "<<outputfile_name<<" = "<<avg_percent_err<<endl;
      cout<<"Utility for "<<outputfile_name<<" = "<<utility<<endl;
      runtime_utility_file<<i<<'\t'<<runtime<<'\t'<<utility<<'\t'<<baseline_runtime<<'\n';
    }
    else{
      cout<<"Error in file "<<outputfile_name<<'\n';   //// ignores the erroneous file and continues the loop
    }
    i += difference;
  }
  return 0;
}
